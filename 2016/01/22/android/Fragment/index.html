<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Fragment | Never Ever Stop Trying</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="android学了一段时间了，文章看了无数，优秀的文章很多，各种技术介绍的也都十分清晰，但是总感觉差点什么，也许把自己的感受记录下来才能形成自己的东西。一直使用有道云笔记，各种文章记录了上百篇，这些文章通常只是静静的躺在那里,虽然已经记录在我的笔记里，但那仍然不是属于的我东西。我们要学会管理自己的知识。关于知识管理方面，请参考文章：程序员的知识管理  
因为最近用到了Fragment，所以先从Fr">
<meta property="og:type" content="article">
<meta property="og:title" content="Fragment">
<meta property="og:url" content="http://yoursite.com/2016/01/22/android/Fragment/index.html">
<meta property="og:site_name" content="Never Ever Stop Trying">
<meta property="og:description" content="android学了一段时间了，文章看了无数，优秀的文章很多，各种技术介绍的也都十分清晰，但是总感觉差点什么，也许把自己的感受记录下来才能形成自己的东西。一直使用有道云笔记，各种文章记录了上百篇，这些文章通常只是静静的躺在那里,虽然已经记录在我的笔记里，但那仍然不是属于的我东西。我们要学会管理自己的知识。关于知识管理方面，请参考文章：程序员的知识管理  
因为最近用到了Fragment，所以先从Fr">
<meta property="og:updated_time" content="2016-01-29T08:06:41.145Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Fragment">
<meta name="twitter:description" content="android学了一段时间了，文章看了无数，优秀的文章很多，各种技术介绍的也都十分清晰，但是总感觉差点什么，也许把自己的感受记录下来才能形成自己的东西。一直使用有道云笔记，各种文章记录了上百篇，这些文章通常只是静静的躺在那里,虽然已经记录在我的笔记里，但那仍然不是属于的我东西。我们要学会管理自己的知识。关于知识管理方面，请参考文章：程序员的知识管理  
因为最近用到了Fragment，所以先从Fr">
  
    <link rel="alternative" href="/atom.xml" title="Never Ever Stop Trying" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/image/icon.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">MjLao</a></h1>
		</hgroup>

		
		<p class="header-subtitle">Happiness is a way station between too much and too little</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>標籤</li>
						
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="/#" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="/#" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="/#" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/android/" style="font-size: 10px;">android</a>
					</div>
				</section>
				
				
				

				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">MjLao</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="/image/icon.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">MjLao</h1>
			</hgroup>
			
			<p class="header-subtitle">Happiness is a way station between too much and too little</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="/#" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="/#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="/#" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap"><article id="post-android/Fragment" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/01/22/android/Fragment/" class="article-date">
  	<time datetime="2016-01-22T00:44:46.000Z" itemprop="datePublished">2016-01-22</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Fragment
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android/">android</a></li></ul>
	</div>

        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>android学了一段时间了，文章看了无数，优秀的文章很多，各种技术介绍的也都十分清晰，但是总感觉差点什么，也许把自己的感受记录下来才能形成自己的东西。一直使用有道云笔记，各种文章记录了上百篇，这些文章通常只是静静的躺在那里,虽然已经记录在我的笔记里，但那仍然不是属于的我东西。我们要学会管理自己的知识。<br>关于知识管理方面，请参考文章：<a href="http://blog.xiaohansong.com/2016/01/16/kownledge-Management/" target="_blank" rel="external">程序员的知识管理</a>  </p>
<p>因为最近用到了Fragment，所以先从Fragment开始</p>
<a id="more"></a>
<h3 id="1_u3001Android_Fragment"><a href="#1_u3001Android_Fragment" class="headerlink" title="1、Android Fragment"></a>1、Android Fragment</h3><p>当我第一次看到fragment这个单词的时候，我立马打开词典查了一下：</p>
<blockquote>
<p>fragment : [‘frægm(ə)nt]<br>n. 碎片；片断或不完整部分<br>vt. 使成碎片<br>vi. 破碎或裂开</p>
</blockquote>
<p>事实上，在阅读英文技术文档的时候，遇到没有见过的单词，我总是想要先查一下，尤其是发音。即便是很多不认识的单词，能够猜出其大意而且不影响阅读，事后也要去查一下，这应该也算是一种强迫症吧，不过这也让我阅读英文文档的水平提高了不少。</p>
<p>fragment的含义是碎片，这让我首先想到了玩具拼图的碎片。许多张碎片正确的结合到一起形成了完整的拼图。联系到软件开发方面，很明显它的相关词汇应该是模块、组件、可插拔。模块化开发的好处是可以很方便的<strong>增加、替换、删除</strong>某个模块,同时有着有很好的扩展性和适应性。事实上android中的fragment也正是基于这个理念来做的。</p>
<p>因此android fragment产生的目的：</p>
<blockquote>
<p>为了适应不同尺寸，不同分辨率的屏幕，为某个界面增加独立的业务逻辑，可以在Activity中动态的添加、替换和移除某个Fragment</p>
</blockquote>
<p>有了Fragment，就可以将Activity中的业务逻辑进行分解，原先Activity复杂的代码可以分别在Fragment中实现。下面我们就具体来看一下fragment是如何使用的。</p>
<h3 id="2_u3001Fragment__u751F_u547D_u5468_u671F"><a href="#2_u3001Fragment__u751F_u547D_u5468_u671F" class="headerlink" title="2、Fragment 生命周期"></a>2、Fragment 生命周期</h3><p>生命周期是一个很重要的概念，因为一个模块加入到系统中（生命开始）到从系统中移除（生命结束）这整个过程中肯定有很多环节，通过这些个环节一步一步完成fragment的使命，下面来看一下<br><a href="http://developer.android.com/reference/android/app/Fragment.html" target="_blank" rel="external">官方说明</a>,照顾一下看不到的同学，贴过来：</p>
<blockquote>
<p>A Fragment is a piece of an application’s user interface or behavior that can be placed in an Activity. Interaction with fragments is done through FragmentManager, which can be obtained via Activity.getFragmentManager() and Fragment.getFragmentManager().<br>The Fragment class can be used many ways to achieve a wide variety of results. In its core, it represents a particular operation or interface that is running within a larger Activity. A Fragment is closely tied to the Activity it is in, and can not be used apart from one. Though Fragment defines its own lifecycle, that lifecycle is dependent on its activity: if the activity is stopped, no fragments inside of it can be started; when the activity is destroyed, all fragments will be destroyed.<br>All subclasses of Fragment must include a public no-argument constructor. The framework will often re-instantiate a fragment class when needed, in particular during state restore, and needs to be able to find this constructor to instantiate it. If the no-argument constructor is not available, a runtime exception will occur in some cases during state restore.<br>Though a Fragment’s lifecycle is tied to its owning activity, it has its own wrinkle on the standard activity lifecycle. It includes basic activity lifecycle methods such as onResume(), but also important are methods related to interactions with the activity and UI generation.<br>The core series of lifecycle methods that are called to bring a fragment up to resumed state (interacting with the user) are:<br><strong>onAttach(Activity)</strong> called once the fragment is associated with its activity.<br><strong>onCreate(Bundle)</strong> called to do initial creation of the fragment.<br><strong>onCreateView(LayoutInflater, ViewGroup, Bundle)</strong> creates and returns the view hierarchy associated with the fragment.<br><strong>onActivityCreated(Bundle) </strong>tells the fragment that its activity has completed its own Activity.onCreate().<br><strong>onViewStateRestored(Bundle)</strong> tells the fragment that all of the saved state of its view hierarchy has been restored.<br><strong>onStart()</strong> makes the fragment visible to the user (based on its containing activity being started).<br><strong>onResume()</strong> makes the fragment begin interacting with the user (based on its containing activity being resumed).  </p>
<p></p><p>As a fragment is no longer being used, it goes through a reverse series of callbacks:<br><strong>onPause()</strong> fragment is no longer interacting with the user either because its activity is being paused or a fragment operation is modifying it in the activity.<br><strong>onStop()</strong> fragment is no longer visible to the user either because its activity is being stopped or a fragment operation is modifying it in the activity.<br><strong>onDestroyView()</strong> allows the fragment to clean up resources associated with its View.<br><strong>onDestroy()</strong> called to do final cleanup of the fragment’s state.<br><strong>onDetach()</strong> called immediately prior to the fragment no longer being associated with its activity.</p>
</blockquote>
<p>看不懂的同学请直接看下面的解释：</p>
<p>首先Fragment是绑定到Activity中的，可以通过FragmentManager管理。FragmentManager可以通过Activity的getFragmentManager() 和 Fragment的getFragmentManager()方法拿到，这里补充一个方法Fragment的getChildFragmentManager()，这个manager用来管理嵌套在Fragment内部的Fragment,可以保证内部的Fragment与外部的Fragment生命周期同步。当外面的Fragment销毁时，内部的也会销毁。</p>
<p>Fragment虽然有自己的生命周期，但是它不能独立存在，必须绑定到Activity中，并且受Activity生命周期的影响。如果Activity处于stoped状态，它所有的fragment也会变为stoped,如果Activity destroyed，fragment也将destroyed。</p>
<p>Fragment的子类必须包含一个无参构造方法，因为框架有可能会重新初始化Fragment,尤其是在需要恢复之前保存的状态的时候会调用无参的构造方法。</p>
<p>Fragment生命周期相关方法如下：</p>
<blockquote>
<p><strong>onAttach(Activity)</strong> : 当fragment关联到Activity时调用，新版代码中已经废弃，改为<strong>onAttach(Context context)</strong>，通过这个方法可以在fragment中拿到context，此处改动应该还是鼓励开发者在fragment中撇清与activity的关系，antivity的生命周期不应该由fragment控制。<br><strong>onCreate(Bundle):</strong>看下源码中的描述，在onAttach之后调用，在onCreate之前调用，此处的操作为初始化fragment<br> <strong>onCreateView(LayoutInflater, ViewGroup, Bundle):</strong> 创建并返回需要展示的视图，使用inflater.inflate()方法使用布局文件创建视图<br><strong>onActivityCreated(Bundle)：</strong> 通知fragment，它所在的activity.onCreate方法已经执行完成<br><strong>onViewStateRestored(Bundle):</strong> 通知fragment，之前保存的状态已经恢复，可以在这个方法恢复视图的状态，例如复选框的选中状态，调用时机为<strong>onActivityCreated</strong>之后，<strong>onStart</strong>之前<br><strong>onStart():</strong> 当fragment对用户可见时调用，通常与activity的start方法绑定  <strong>onResume():</strong> 当fragment处于可以与用户交互状态时调用，与activity的onResume方法绑定  </p>
</blockquote>
<p>当fragment不再被使用时，类似activity生命周期，会按照fragment创建相反的行为执行一系列方法：</p>
<blockquote>
<p><strong>onPause():</strong> 对应onResume,fragment不再处于可以与用户交互的状态<br><strong>onStop()：</strong> 对应onStart，fragment不再对用户可见<br><strong>onDestroyView()：</strong> 对应 onCreateView,清理相关视图资源<br><strong>onDestroy()：</strong> 对应onCreate,清理fragment相关状态<br><strong>onDetach()：</strong> 对应 onAttach,解除与activity的关联关系</p>
</blockquote>
<h3 id="3_u3001_u901A_u8FC7_u4EE3_u7801_u611F_u53D7_u4E00_u4E0B_u751F_u547D_u5468_u671F"><a href="#3_u3001_u901A_u8FC7_u4EE3_u7801_u611F_u53D7_u4E00_u4E0B_u751F_u547D_u5468_u671F" class="headerlink" title="3、通过代码感受一下生命周期"></a>3、通过代码感受一下生命周期</h3><p>布局文件 <strong>activity_main.xml</strong>  </p>
<pre><code>&lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;match_parent&quot;&gt;

&lt;fragment
    android:id=&quot;@+id/titles&quot;
    class=&quot;com.anzxy.fragmentlifecycle.FragmentA&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot; /&gt;
&lt;/FrameLayout&gt;
</code></pre><p>创建一个FramentA  ,加入生命周期方法名称打印</p>
<p>MainActivity类：  </p>
<pre><code>public class MainActivity extends AppCompatActivity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
    }
}
</code></pre><p>在mainActivity加入Activity生命周期的执行的打印，具体的就不贴了，看结果：</p>
<blockquote>
<p>MainActivity: ########## onCreate父类方法调用之前 ############<br>MainActivity: ########## setContentView方法调用之前 ############<br>FragmentA: onAttach<br>FragmentA: onCreate<br>FragmentA: onCreateView<br>FragmentA: onViewCreated<br>MainActivity: ########## setContentView方法调用之后 ############<br>MainActivity: ########## onStart父类方法调用之前 ############<br>FragmentA: onActivityCreated<br>FragmentA: onViewStateRestored<br>FragmentA: onStart<br>MainActivity: ########## onStart父类方法调用之后 ############<br>MainActivity: ########## onResume父类方法调用之前 ############<br>MainActivity: ########## onResume父类方法调用之后 ############<br>FragmentA: onResume<br><strong>点击返回按钮</strong><br>MainActivity: ########## onPause父类方法调用之前 ############<br>FragmentA: onPause<br>MainActivity: ########## onPause父类方法调用之后 ############<br>MainActivity: ########## onStop父类方法调用之前 ############<br>FragmentA: onStop<br>MainActivity: ########## onStop父类方法调用之后 ############<br>MainActivity: ########## onDestroy父类方法调用之前 ############<br>FragmentA: onDestroyView<br>FragmentA: onDestroy<br>FragmentA: onDetach<br>MainActivity: ########## onDestroy父类方法调用之后 ############  </p>
</blockquote>
<p>更改Fragment创建方式</p>
<pre><code>protected void onCreate(Bundle savedInstanceState) {
    Log.i(TAG, &quot;########## onCreate父类方法调用之前 ############&quot;);

    FragmentA fragmentA = new FragmentA();
    super.onCreate(savedInstanceState);
    FragmentTransaction transaction =  
        this.getSupportFragmentManager().beginTransaction();
    transaction.add(R.id.main_frame,fragmentA);
    transaction.commit();
    Log.i(TAG, &quot;########## setContentView方法调用之前 ############&quot;);
    setContentView(R.layout.activity_main);
    Log.i(TAG, &quot;########## setContentView方法调用之后 ############&quot;);
}
</code></pre><blockquote>
<p>MainActivity: ########## onCreate父类方法调用之前 ############<br>MainActivity: ########## setContentView方法调用之前 ############<br>MainActivity: ########## setContentView方法调用之后 ############<br>MainActivity: ########## onStart父类方法调用之前 ############<br>FragmentA: onAttach<br>FragmentA: onCreate<br>FragmentA: onCreateView<br>FragmentA: onViewCreated<br>FragmentA: onActivityCreated<br>FragmentA: onViewStateRestored<br>FragmentA: onStart<br>MainActivity: ########## onStart父类方法调用之后 ############<br>MainActivity: ########## onResume父类方法调用之前 ############<br>MainActivity: ########## onResume父类方法调用之后 ############<br>FragmentA: onResume<br><strong>点击返回按钮</strong><br>MainActivity: ########## onPause父类方法调用之前 ############<br>FragmentA: onPause<br>MainActivity: ########## onPause父类方法调用之后 ############<br>MainActivity: ########## onStop父类方法调用之前 ############<br>FragmentA: onStop<br>MainActivity: ########## onStop父类方法调用之后 ############<br>MainActivity: ########## onDestroy父类方法调用之前 ############<br>FragmentA: onDestroyView<br>FragmentA: onDestroy<br>FragmentA: onDetach<br>MainActivity: ########## onDestroy父类方法调用之后 ############  </p>
</blockquote>
<p>此处你会发现两种创建方式fragment生命周期执行的时机不一样，后面会从源码层面进行解释。</p>
<h3 id="4_u3001fragment_u63A7_u5236"><a href="#4_u3001fragment_u63A7_u5236" class="headerlink" title="4、fragment控制"></a>4、fragment控制</h3><p>FragmentManager 获取</p>
<ol>
<li><p>activity中 getFragmentManager</p>
</li>
<li><p>如果使用android.support.v4.app.Fragment，则需要用FragmentActivity中的getSupportFragmentManager  </p>
</li>
<li><p>使用Fragment的getFragmentManager(),注意此方法只有在fragment被纳入到事务中时才不为空,返回的是activity获取的mananger</p>
</li>
<li>使用Fragment的getChildFragmentManager(),使用它来管理内部的fragment </li>
</ol>
<p>FragmentManager常用方法：<br><strong>addOnBackStackChangedListener()：</strong>添加一个栈变化的监听<br><strong>beginTransaction()：</strong>开启一个fragment操作的事务<br><strong>findFragmentById()：</strong>通过ID查找fragment,首先查找添加到当前activity中的，如果没有，则查找当前所有栈中的fragment<br><strong>findFragmentByTag:</strong>同findFragmentById，只是通过tag标志查找<br><strong>popBackStack():</strong>栈回退，相当于撤销加入到栈中的操作，此方法是异步的，回退操作请求会加入到循环队列中，回退操作不会立即执行。<br><strong>popBackStackImmediate():</strong>与popBackStack不同的是，此方式是同步的，会立即执行<br><strong>execPendingActions():</strong>立即执行加入到fragmentTransaction的操作（同时会从主线程循环队列中移除）</p>
<p>FragmentTransaction常用方法,可链式调用：  </p>
<p><strong>FragmentTransaction add(IdRes int containerViewId, Fragment fragment)：</strong>添加一个Fragment,containerViewId容器ID,fragment中onCreateView返回的视图会添加到这个容器中<br><strong>FragmentTransaction remove(Fragment fragment)：</strong>移除一个已经存在的fragment，如果此事务没有执行addToBackStack，则被移除的fragment会销毁<br><strong>FragmentTransaction replace(@IdRes int containerViewId, Fragment fragment)：</strong>替换视图容器中已经存在的fragment，此操作相当于remove()和add()<br><strong>FragmentTransaction detach(Fragment fragment)：</strong>把fragment从UI中脱离，但是fragmentManager仍然受fragment的管理<br><strong>FragmentTransaction attach(Fragment fragment)：</strong>把之前脱离的fragment重新添加到UI中<br><strong>FragmentTransaction hide(Fragment fragment):</strong>隐藏一个已经存在的fragment,实际上是添加到containerView中的相关view<br><strong>FragmentTransaction show(Fragment fragment)：</strong>显示一个隐藏的fragment<br><strong>FragmentTransaction addToBackStack(@Nullable String name):</strong>把这个事务加入到栈中，当执行popBackStack时，此事务中的操作可以回退<br><strong>int commit()：</strong>事务提交，但是事务操作不会立即执行，它会加入到主线程循环队列中等待执行(handler.post())  </p>
<p>可以看到commit()方法不会立即执行，因此在第二种方式创建fragment的时候，activity的onCreate()方法内不会执行fragment生命周期，查看一下FragmentActivity的onStart()源码：  </p>
<pre><code>protected void onStart() {
    super.onStart();

    mStopped = false;
    mReallyStopped = false;
    mHandler.removeMessages(MSG_REALLY_STOPPED);

    if (!mCreated) {
        mCreated = true;
        //通知当前所有的fragment，Activity已创建
        mFragments.dispatchActivityCreated();
    }

    mFragments.noteStateNotSaved();

    //之前commit的操作在这个地方执行，不用排队等待
    mFragments.execPendingActions();

    mFragments.doLoaderStart();

    // NOTE: HC onStart goes here.

    //更新状态到start
    mFragments.dispatchStart();
    mFragments.reportLoaderStart();
}
</code></pre><p>Fragment状态:</p>
<pre><code>static final int INITIALIZING = 0;     // Not yet created.
static final int CREATED = 1;          // Created.
static final int ACTIVITY_CREATED = 2; // The activity has finished its creation.
static final int STOPPED = 3;          // Fully created, not started.
static final int STARTED = 4;          // Created and started, not resumed.
static final int RESUMED = 5;          // Created started and resumed.
</code></pre><p>如果activity状态处于resume状态,那么新增加的fragment状态会从0变为5，fragment生命周期的相关方法会依次执行。</p>
<p>在activity的生命周期相关方法内会更新fragment的状态:  </p>
<pre><code>mFragments.dispatchCreate();  
mFragments.dispatchActivityCreated();
mFragments.dispatchStart();
mFragments.dispatchResume();
mFragments.dispatchPause();
mFragments.dispatchStop();
mFragments.dispatchDestroy();
</code></pre><h3 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h3><p>其实android提供给我们的Fragment类是一个模板，我么按照这个模板编写代码实现自己的逻辑，就能够享受到Fragment带给我们的便利，另外在我们日常编写代码的时候如果碰到类似情况，也可以仿照这个思路来设计组织自己的代码，增加业务的灵活性。</p>
<p>附上一段Fragment切换的<a href="https://github.com/emf1002/Android-Learn.git" target="_blank" rel="external">演示代码</a></p>
<p></p><p>文章参考：<br><a href="http://blog.csdn.net/lmj623565791/article/details/37970961" target="_blank" rel="external">Android Fragment 真正的完全解析</a></p>

      
    </div>
    
  </div>
  
    
  
</article>


<div class="share_jia">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">分享到: &nbsp; </span>
		<a class="jiathis_button_facebook"></a> 
    <a class="jiathis_button_twitter"></a>
    <a class="jiathis_button_plus"></a> 
    <a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>






<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="android/Fragment" data-title="Fragment" data-url="http://yoursite.com/2016/01/22/android/Fragment/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"mjlao"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>




</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 MjLao
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>