[{"title":"传统WEB项目转Spring Boot---注解","date":"2017-02-20T00:50:28.230Z","path":"2017/02/20/web/传统WEB项目转Spring Boot ---注解/","text":"关于传统WEB项目转为一个Sring Boot项目一些配置,关于注解的解释 1、配置注解首先关于配置相关的注解有@Configuration @ComponentScan @EnableAutoConfiguration @ImportResource等等 @Configuration作用类似于一个Spring的xml配置文件，使用在类上，可以类里面的方法上使用@Bean注解配置一个Bean @ComponentScan@ComponentScan 作用相当于xml配置文件里的&lt;context:component-scan&gt; ,可以指定basePackages，默认basePackages为注解类所在的包。 @EnableAutoConfiguration使用Spring Boot自动配置的一个关键注解 ，在spring-boot-autoconfigure的jar包下，有个spring.factories文件，部分代码如下123456789101112131415...# Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\\org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\\org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\\org.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,\\org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\\org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\\org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\\... 这是Spring Boot默认定义全部使用@Configuration注解的类，程序启动时会扫描这些类，并根据条件判断是否启用这些配置，同时还会把含有该注解类的包作为顶层包，搜索自定义的@Configuration @EnableAutoConfiguration 可以使用exclude设置需要排除自动配置的类，使用excludeName设置需要排除的类名 开发调试时，启用Spring Boot debug模式，可以通过日志配置文件配置1&lt;logger name=\"org.springframework.boot\" level=\"DEBUG\"/&gt; 开启日志DEBUG输出后，会输出以下内容1234567891011121314151617181920212223242526=========================AUTO-CONFIGURATION REPORT=========================Positive matches: //匹配到的自动配置的类列表 DataSourceAutoConfiguration matched: //类名 - @ConditionalOnClass found required classes 'javax.sql.DataSource'.... Negative matches: //未匹配的类列表----------------- ActiveMQAutoConfiguration: //类名 Did not match: - @ConditionalOnClass did not find required classes 'javax.jms.ConnectionFactory', ...Exclusions: //排除的自动配置列表----------- org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration ...Unconditional classes: //无条件匹配的类,但在方法上可能存在匹配条件---------------------- org.springframework.boot.autoconfigure.web.WebClientAutoConfiguration ... 根据以上输出内容，可以灵活配置哪些需要自动出来里，哪些需要排除 @SpringBootApplication@SpringBootApplication 相当于以上三个注解同时作用。 @Import作用相当于xml配置文件中的标签,可以导入@Configuration注解的类 @ImportResource作用类似于@Import，可以导入一个xml配置文件 2、条件注解Class条件@ConditionalOnClass@ConditionalOnMissingClass通过设置value属性来配置classpath下是否含有特定的类来决定是否启用该配置另外也可以通过name属性来配置类名称。 Bean条件@ConditionalOnBean@ConditionalOnMissingBean通过容器中是否含有某个Bean来决定是否启用该配置，可以通过Bean的类型或name来配置 Property条件@ConditionalOnProperty可以通过配置属性前缀prefix和name等来检查配置文件中是否包含相关配置来决定是否启用该配置 Resource条件@ConditionalOnResource包含指定的资源文件是才启用该配置 Web application条件@ConditionalOnWebApplication@ConditionalOnNotWebApplication通过是否为一个‘web application’来决定是否启用 3、配置排序注解@AutoConfigureAfter@AutoConfigureBefore@AutoConfigureOrder 这几个注解用于标识该配置类在其他某个配置之前或者之后生效，通常用于开发starter项目时。关于starter项目开发，可参考Creating your own starter 通常开发starter应该在autoconfigure项目中加入以下依赖：12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-autoconfigure-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; spring-boot-configuration-processor用于生成spring-configuration-metadata.json,里面包含了属性配置信息，可用于编写配置文件如application.xml时，供IDE进行配置代码提示 spring-boot-autoconfigure-processor用于根据排序注解生成文件spring-autoconfigure-metadata.properties,里面包含了配置的顺序信息","tags":[{"name":"web","slug":"web","permalink":"http://yoursite.com/tags/web/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"}]},{"title":"Fragment","date":"2016-01-22T00:44:46.000Z","path":"2016/01/22/android/Fragment/","text":"android学了一段时间了，文章看了无数，优秀的文章很多，各种技术介绍的也都十分清晰，但是总感觉差点什么，也许把自己的感受记录下来才能形成自己的东西。一直使用有道云笔记，各种文章记录了上百篇，这些文章通常只是静静的躺在那里,虽然已经记录在我的笔记里，但那仍然不是属于的我东西。我们要学会管理自己的知识。关于知识管理方面，请参考文章：程序员的知识管理 因为最近用到了Fragment，所以先从Fragment开始 1、Android Fragment当我第一次看到fragment这个单词的时候，我立马打开词典查了一下： fragment : [‘frægm(ə)nt]n. 碎片；片断或不完整部分vt. 使成碎片vi. 破碎或裂开 事实上，在阅读英文技术文档的时候，遇到没有见过的单词，我总是想要先查一下，尤其是发音。即便是很多不认识的单词，能够猜出其大意而且不影响阅读，事后也要去查一下，这应该也算是一种强迫症吧，不过这也让我阅读英文文档的水平提高了不少。 fragment的含义是碎片，这让我首先想到了玩具拼图的碎片。许多张碎片正确的结合到一起形成了完整的拼图。联系到软件开发方面，很明显它的相关词汇应该是模块、组件、可插拔。模块化开发的好处是可以很方便的增加、替换、删除某个模块,同时有着有很好的扩展性和适应性。事实上android中的fragment也正是基于这个理念来做的。 因此android fragment产生的目的： 为了适应不同尺寸，不同分辨率的屏幕，为某个界面增加独立的业务逻辑，可以在Activity中动态的添加、替换和移除某个Fragment 有了Fragment，就可以将Activity中的业务逻辑进行分解，原先Activity复杂的代码可以分别在Fragment中实现。下面我们就具体来看一下fragment是如何使用的。 2、Fragment 生命周期生命周期是一个很重要的概念，因为一个模块加入到系统中（生命开始）到从系统中移除（生命结束）这整个过程中肯定有很多环节，通过这些个环节一步一步完成fragment的使命，下面来看一下官方说明,照顾一下看不到的同学，贴过来： A Fragment is a piece of an application’s user interface or behavior that can be placed in an Activity. Interaction with fragments is done through FragmentManager, which can be obtained via Activity.getFragmentManager() and Fragment.getFragmentManager().The Fragment class can be used many ways to achieve a wide variety of results. In its core, it represents a particular operation or interface that is running within a larger Activity. A Fragment is closely tied to the Activity it is in, and can not be used apart from one. Though Fragment defines its own lifecycle, that lifecycle is dependent on its activity: if the activity is stopped, no fragments inside of it can be started; when the activity is destroyed, all fragments will be destroyed.All subclasses of Fragment must include a public no-argument constructor. The framework will often re-instantiate a fragment class when needed, in particular during state restore, and needs to be able to find this constructor to instantiate it. If the no-argument constructor is not available, a runtime exception will occur in some cases during state restore.Though a Fragment’s lifecycle is tied to its owning activity, it has its own wrinkle on the standard activity lifecycle. It includes basic activity lifecycle methods such as onResume(), but also important are methods related to interactions with the activity and UI generation.The core series of lifecycle methods that are called to bring a fragment up to resumed state (interacting with the user) are:onAttach(Activity) called once the fragment is associated with its activity.onCreate(Bundle) called to do initial creation of the fragment.onCreateView(LayoutInflater, ViewGroup, Bundle) creates and returns the view hierarchy associated with the fragment.onActivityCreated(Bundle) tells the fragment that its activity has completed its own Activity.onCreate().onViewStateRestored(Bundle) tells the fragment that all of the saved state of its view hierarchy has been restored.onStart() makes the fragment visible to the user (based on its containing activity being started).onResume() makes the fragment begin interacting with the user (based on its containing activity being resumed). As a fragment is no longer being used, it goes through a reverse series of callbacks:onPause() fragment is no longer interacting with the user either because its activity is being paused or a fragment operation is modifying it in the activity.onStop() fragment is no longer visible to the user either because its activity is being stopped or a fragment operation is modifying it in the activity.onDestroyView() allows the fragment to clean up resources associated with its View.onDestroy() called to do final cleanup of the fragment’s state.onDetach() called immediately prior to the fragment no longer being associated with its activity. 看不懂的同学请直接看下面的解释： 首先Fragment是绑定到Activity中的，可以通过FragmentManager管理。FragmentManager可以通过Activity的getFragmentManager() 和 Fragment的getFragmentManager()方法拿到，这里补充一个方法Fragment的getChildFragmentManager()，这个manager用来管理嵌套在Fragment内部的Fragment,可以保证内部的Fragment与外部的Fragment生命周期同步。当外面的Fragment销毁时，内部的也会销毁。 Fragment虽然有自己的生命周期，但是它不能独立存在，必须绑定到Activity中，并且受Activity生命周期的影响。如果Activity处于stoped状态，它所有的fragment也会变为stoped,如果Activity destroyed，fragment也将destroyed。 Fragment的子类必须包含一个无参构造方法，因为框架有可能会重新初始化Fragment,尤其是在需要恢复之前保存的状态的时候会调用无参的构造方法。 Fragment生命周期相关方法如下： onAttach(Activity) : 当fragment关联到Activity时调用，新版代码中已经废弃，改为onAttach(Context context)，通过这个方法可以在fragment中拿到context，此处改动应该还是鼓励开发者在fragment中撇清与activity的关系，antivity的生命周期不应该由fragment控制。onCreate(Bundle):看下源码中的描述，在onAttach之后调用，在onCreate之前调用，此处的操作为初始化fragment onCreateView(LayoutInflater, ViewGroup, Bundle): 创建并返回需要展示的视图，使用inflater.inflate()方法使用布局文件创建视图onActivityCreated(Bundle)： 通知fragment，它所在的activity.onCreate方法已经执行完成onViewStateRestored(Bundle): 通知fragment，之前保存的状态已经恢复，可以在这个方法恢复视图的状态，例如复选框的选中状态，调用时机为onActivityCreated之后，onStart之前onStart(): 当fragment对用户可见时调用，通常与activity的start方法绑定 onResume(): 当fragment处于可以与用户交互状态时调用，与activity的onResume方法绑定 当fragment不再被使用时，类似activity生命周期，会按照fragment创建相反的行为执行一系列方法： onPause(): 对应onResume,fragment不再处于可以与用户交互的状态onStop()： 对应onStart，fragment不再对用户可见onDestroyView()： 对应 onCreateView,清理相关视图资源onDestroy()： 对应onCreate,清理fragment相关状态onDetach()： 对应 onAttach,解除与activity的关联关系 3、通过代码感受一下生命周期布局文件 activity_main.xml12345678910&lt;FrameLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;fragment android:id=\"@+id/titles\" class=\"com.anzxy.fragmentlifecycle.FragmentA\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" /&gt;&lt;/FrameLayout&gt; 创建一个FramentA ,加入生命周期方法名称打印 MainActivity类： 1234567public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125;&#125; 在mainActivity加入Activity生命周期的执行的打印，具体的就不贴了，看结果： MainActivity: ########## onCreate父类方法调用之前 ############MainActivity: ########## setContentView方法调用之前 ############FragmentA: onAttachFragmentA: onCreateFragmentA: onCreateViewFragmentA: onViewCreatedMainActivity: ########## setContentView方法调用之后 ############MainActivity: ########## onStart父类方法调用之前 ############FragmentA: onActivityCreatedFragmentA: onViewStateRestoredFragmentA: onStartMainActivity: ########## onStart父类方法调用之后 ############MainActivity: ########## onResume父类方法调用之前 ############MainActivity: ########## onResume父类方法调用之后 ############FragmentA: onResume点击返回按钮MainActivity: ########## onPause父类方法调用之前 ############FragmentA: onPauseMainActivity: ########## onPause父类方法调用之后 ############MainActivity: ########## onStop父类方法调用之前 ############FragmentA: onStopMainActivity: ########## onStop父类方法调用之后 ############MainActivity: ########## onDestroy父类方法调用之前 ############FragmentA: onDestroyViewFragmentA: onDestroyFragmentA: onDetachMainActivity: ########## onDestroy父类方法调用之后 ############ 更改Fragment创建方式 12345678910111213protected void onCreate(Bundle savedInstanceState) &#123; Log.i(TAG, \"########## onCreate父类方法调用之前 ############\"); FragmentA fragmentA = new FragmentA(); super.onCreate(savedInstanceState); FragmentTransaction transaction = this.getSupportFragmentManager().beginTransaction(); transaction.add(R.id.main_frame,fragmentA); transaction.commit(); Log.i(TAG, \"########## setContentView方法调用之前 ############\"); setContentView(R.layout.activity_main); Log.i(TAG, \"########## setContentView方法调用之后 ############\");&#125; MainActivity: ########## onCreate父类方法调用之前 ############MainActivity: ########## setContentView方法调用之前 ############MainActivity: ########## setContentView方法调用之后 ############MainActivity: ########## onStart父类方法调用之前 ############FragmentA: onAttachFragmentA: onCreateFragmentA: onCreateViewFragmentA: onViewCreatedFragmentA: onActivityCreatedFragmentA: onViewStateRestoredFragmentA: onStartMainActivity: ########## onStart父类方法调用之后 ############MainActivity: ########## onResume父类方法调用之前 ############MainActivity: ########## onResume父类方法调用之后 ############FragmentA: onResume点击返回按钮MainActivity: ########## onPause父类方法调用之前 ############FragmentA: onPauseMainActivity: ########## onPause父类方法调用之后 ############MainActivity: ########## onStop父类方法调用之前 ############FragmentA: onStopMainActivity: ########## onStop父类方法调用之后 ############MainActivity: ########## onDestroy父类方法调用之前 ############FragmentA: onDestroyViewFragmentA: onDestroyFragmentA: onDetachMainActivity: ########## onDestroy父类方法调用之后 ############ 此处你会发现两种创建方式fragment生命周期执行的时机不一样，后面会从源码层面进行解释。 4、fragment控制FragmentManager 获取 activity中 getFragmentManager 如果使用android.support.v4.app.Fragment，则需要用FragmentActivity中的getSupportFragmentManager 使用Fragment的getFragmentManager(),注意此方法只有在fragment被纳入到事务中时才不为空,返回的是activity获取的mananger 使用Fragment的getChildFragmentManager(),使用它来管理内部的fragment FragmentManager常用方法：addOnBackStackChangedListener()：添加一个栈变化的监听beginTransaction()：开启一个fragment操作的事务findFragmentById()：通过ID查找fragment,首先查找添加到当前activity中的，如果没有，则查找当前所有栈中的fragmentfindFragmentByTag:同findFragmentById，只是通过tag标志查找popBackStack():栈回退，相当于撤销加入到栈中的操作，此方法是异步的，回退操作请求会加入到循环队列中，回退操作不会立即执行。popBackStackImmediate():与popBackStack不同的是，此方式是同步的，会立即执行execPendingActions():立即执行加入到fragmentTransaction的操作（同时会从主线程循环队列中移除） FragmentTransaction常用方法,可链式调用： FragmentTransaction add(IdRes int containerViewId, Fragment fragment)：添加一个Fragment,containerViewId容器ID,fragment中onCreateView返回的视图会添加到这个容器中FragmentTransaction remove(Fragment fragment)：移除一个已经存在的fragment，如果此事务没有执行addToBackStack，则被移除的fragment会销毁FragmentTransaction replace(@IdRes int containerViewId, Fragment fragment)：替换视图容器中已经存在的fragment，此操作相当于remove()和add()FragmentTransaction detach(Fragment fragment)：把fragment从UI中脱离，但是fragmentManager仍然受fragment的管理FragmentTransaction attach(Fragment fragment)：把之前脱离的fragment重新添加到UI中FragmentTransaction hide(Fragment fragment):隐藏一个已经存在的fragment,实际上是添加到containerView中的相关viewFragmentTransaction show(Fragment fragment)：显示一个隐藏的fragmentFragmentTransaction addToBackStack(@Nullable String name):把这个事务加入到栈中，当执行popBackStack时，此事务中的操作可以回退int commit()：事务提交，但是事务操作不会立即执行，它会加入到主线程循环队列中等待执行(handler.post()) 可以看到commit()方法不会立即执行，因此在第二种方式创建fragment的时候，activity的onCreate()方法内不会执行fragment生命周期，查看一下FragmentActivity的onStart()源码： 1234567891011121314151617181920212223242526protected void onStart() &#123; super.onStart(); mStopped = false; mReallyStopped = false; mHandler.removeMessages(MSG_REALLY_STOPPED); if (!mCreated) &#123; mCreated = true; //通知当前所有的fragment，Activity已创建 mFragments.dispatchActivityCreated(); &#125; mFragments.noteStateNotSaved(); //之前commit的操作在这个地方执行，不用排队等待 mFragments.execPendingActions(); mFragments.doLoaderStart(); // NOTE: HC onStart goes here. //更新状态到start mFragments.dispatchStart(); mFragments.reportLoaderStart();&#125; Fragment状态: 123456static final int INITIALIZING = 0; // Not yet created.static final int CREATED = 1; // Created.static final int ACTIVITY_CREATED = 2; // The activity has finished its creation.static final int STOPPED = 3; // Fully created, not started.static final int STARTED = 4; // Created and started, not resumed.static final int RESUMED = 5; // Created started and resumed. 如果activity状态处于resume状态,那么新增加的fragment状态会从0变为5，fragment生命周期的相关方法会依次执行。 在activity的生命周期相关方法内会更新fragment的状态:1234567mFragments.dispatchCreate(); mFragments.dispatchActivityCreated();mFragments.dispatchStart();mFragments.dispatchResume();mFragments.dispatchPause();mFragments.dispatchStop();mFragments.dispatchDestroy(); 总结其实android提供给我们的Fragment类是一个模板，我么按照这个模板编写代码实现自己的逻辑，就能够享受到Fragment带给我们的便利，另外在我们日常编写代码的时候如果碰到类似情况，也可以仿照这个思路来设计组织自己的代码，增加业务的灵活性。 附上一段Fragment切换的演示代码 文章参考：Android Fragment 真正的完全解析","tags":[{"name":"android","slug":"android","permalink":"http://yoursite.com/tags/android/"}]}]